#!/usr/bin/env python3
"""
GNU Test Statistics Visualizer

This script reads the statistics JSON file generated by download.py
and creates various visualizations and reports.

Usage:
    python visualize.py [options] <statistics.json>

Options:
    --output-dir DIR     Directory for output files (default: ./reports)
    --format FORMAT      Output format: html, markdown, json (default: markdown)
    --charts             Generate charts (requires matplotlib)
    --verbose            Enable verbose output

Requirements for charts:
    pip install matplotlib seaborn
"""

import argparse
import json
import sys
from datetime import datetime
from pathlib import Path
from collections import defaultdict

try:
    import matplotlib.pyplot as plt
    import matplotlib.dates as mdates
    from matplotlib.patches import Rectangle
    import seaborn as sns
    MATPLOTLIB_AVAILABLE = True
except ImportError:
    MATPLOTLIB_AVAILABLE = False


class GnuTestStatsVisualizer:
    def __init__(self, stats_data, output_dir, format_type='markdown'):
        self.stats = stats_data
        self.output_dir = Path(output_dir)
        self.format_type = format_type
        self.output_dir.mkdir(parents=True, exist_ok=True)

    def generate_report(self, include_charts=False):
        """Generate a comprehensive report."""
        if self.format_type == 'markdown':
            return self._generate_markdown_report(include_charts)
        elif self.format_type == 'html':
            return self._generate_html_report(include_charts)
        elif self.format_type == 'json':
            return self._generate_json_report()
        else:
            raise ValueError(f"Unsupported format: {self.format_type}")

    def _generate_markdown_report(self, include_charts=False):
        """Generate a Markdown report."""
        overall = self.stats['overall_statistics']
        metadata = self.stats['metadata']

        report = []
        report.append("# GNU Test Statistics Report")
        report.append(f"*Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*")
        report.append("")

        # Overview
        report.append("## Overview")
        report.append(f"- **Runs Analyzed**: {metadata['runs_analyzed']}")
        report.append(f"- **Total Test Executions**: {overall['total_tests']:,}")
        report.append(f"- **Overall Success Rate**: {overall['overall_success_rate']:.2f}%")
        report.append(f"- **Failure Rate**: {overall['failure_rate']:.2f}%")
        report.append("")

        # Test Results Breakdown
        report.append("## Test Results Breakdown")
        report.append("| Status | Count | Percentage |")
        report.append("|--------|-------|------------|")
        total = overall['total_tests']
        for status in ['pass', 'fail', 'skip', 'error']:
            count = overall[status]
            pct = (count / total * 100) if total > 0 else 0
            report.append(f"| {status.upper()} | {count:,} | {pct:.2f}% |")
        report.append("")

        # Top Utilities by Test Count
        report.append("## Top Utilities by Test Count")
        utils_by_count = sorted(
            self.stats['per_utility_statistics'].items(),
            key=lambda x: x[1]['total_tests'],
            reverse=True
        )[:10]

        report.append("| Utility | Total Tests | Success Rate | Pass | Fail | Skip | Error |")
        report.append("|---------|-------------|--------------|------|------|------|-------|")
        for util, stats in utils_by_count:
            report.append(
                f"| {util} | {stats['total_tests']} | {stats['overall_success_rate']:.1f}% | "
                f"{stats['pass']} | {stats['fail']} | {stats['skip']} | {stats['error']} |"
            )
        report.append("")

        # Most Problematic Utilities
        problematic_utils = sorted(
            [(util, stats) for util, stats in self.stats['per_utility_statistics'].items()
             if stats['fail'] > 0 or stats['error'] > 0],
            key=lambda x: x[1]['fail'] + x[1]['error'],
            reverse=True
        )[:10]

        if problematic_utils:
            report.append("## Most Problematic Utilities")
            report.append("| Utility | Failures | Errors | Success Rate |")
            report.append("|---------|----------|--------|--------------|")
            for util, stats in problematic_utils:
                report.append(
                    f"| {util} | {stats['fail']} | {stats['error']} | {stats['overall_success_rate']:.1f}% |"
                )
            report.append("")

        # Most Failing Tests
        if self.stats['most_failing_tests']:
            report.append("## Most Failing Tests")
            report.append("| Test | Failure Count |")
            report.append("|------|---------------|")
            for test_info in self.stats['most_failing_tests'][:15]:
                test_name = test_info['test'].replace('::', ' â†’ ')
                report.append(f"| `{test_name}` | {test_info['failure_count']} |")
            report.append("")

        # Flaky Tests
        if self.stats['flaky_tests']:
            report.append("## Flaky Tests")
            report.append("Tests that show inconsistent results across runs:")
            report.append("")
            report.append("| Test | Flaky Score | Recent Results |")
            report.append("|------|-------------|----------------|")
            for test_info in self.stats['flaky_tests'][:10]:
                test_name = test_info['test'].replace('::', ' â†’ ')
                recent = ' â†’ '.join(test_info['results'][-5:])  # Last 5 results
                report.append(f"| `{test_name}` | {test_info['flaky_score']:.2f} | {recent} |")
            report.append("")

        # Trend Analysis
        if self.stats['trend_analysis']:
            report.append("## Success Rate Trend")
            trend_data = self.stats['trend_analysis']
            if len(trend_data) >= 2:
                first_rate = trend_data[0]['success_rate']
                last_rate = trend_data[-1]['success_rate']
                change = last_rate - first_rate
                trend_symbol = "ðŸ“ˆ" if change > 0 else "ðŸ“‰" if change < 0 else "âž¡ï¸"

                report.append(f"Success rate trend: {first_rate:.1f}% â†’ {last_rate:.1f}% ({change:+.1f}%) {trend_symbol}")
                report.append("")

                report.append("| Run | Date | Success Rate | Total Tests |")
                report.append("|-----|------|--------------|-------------|")
                for run in trend_data[-10:]:  # Last 10 runs
                    date = datetime.fromisoformat(run['date'].replace('Z', '+00:00')).strftime('%Y-%m-%d')
                    report.append(f"| #{run['run_number']} | {date} | {run['success_rate']:.1f}% | {run['total_tests']} |")
                report.append("")

        # Per-run statistics summary
        if self.stats['per_run_statistics']:
            report.append("## Recent Runs Summary")
            report.append("| Run | Branch | Date | Conclusion | Success Rate | Tests |")
            report.append("|-----|--------|------|------------|--------------|-------|")
            for run in sorted(self.stats['per_run_statistics'], key=lambda x: x['run_number'], reverse=True)[:10]:
                date = datetime.fromisoformat(run['date'].replace('Z', '+00:00')).strftime('%Y-%m-%d')
                success_rate = (run['pass'] / run['total'] * 100) if run['total'] > 0 else 0
                conclusion_emoji = {"success": "âœ…", "failure": "âŒ", "cancelled": "â¹ï¸"}.get(run['conclusion'], "â“")
                report.append(
                    f"| #{run['run_number']} | {run['branch'][:20]} | {date} | "
                    f"{conclusion_emoji} {run['conclusion']} | {success_rate:.1f}% | {run['total']} |"
                )
            report.append("")

        # Charts section
        if include_charts and MATPLOTLIB_AVAILABLE:
            self._generate_charts()
            report.append("## Charts")
            report.append("Generated charts:")
            report.append("- `success_rate_trend.png` - Success rate over time")
            report.append("- `utility_success_rates.png` - Success rates by utility")
            report.append("- `test_results_pie.png` - Test results distribution")
            report.append("")

        return '\n'.join(report)

    def _generate_charts(self):
        """Generate charts using matplotlib."""
        if not MATPLOTLIB_AVAILABLE:
            print("Warning: matplotlib not available. Skipping chart generation.")
            return

        # Set style
        plt.style.use('seaborn-v0_8' if hasattr(plt.style, 'available') and 'seaborn-v0_8' in plt.style.available else 'default')

        # 1. Success Rate Trend
        if self.stats['trend_analysis']:
            fig, ax = plt.subplots(figsize=(12, 6))
            trend_data = self.stats['trend_analysis']

            dates = [datetime.fromisoformat(run['date'].replace('Z', '+00:00')) for run in trend_data]
            success_rates = [run['success_rate'] for run in trend_data]

            ax.plot(dates, success_rates, marker='o', linewidth=2, markersize=6)
            ax.set_xlabel('Date')
            ax.set_ylabel('Success Rate (%)')
            ax.set_title('GNU Test Success Rate Trend')
            ax.grid(True, alpha=0.3)

            # Format x-axis
            ax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))
            ax.xaxis.set_major_locator(mdates.DayLocator(interval=max(1, len(dates)//10)))
            plt.xticks(rotation=45)

            plt.tight_layout()
            plt.savefig(self.output_dir / 'success_rate_trend.png', dpi=150, bbox_inches='tight')
            plt.close()

        # 2. Utility Success Rates
        utils_data = self.stats['per_utility_statistics']
        if utils_data:
            # Top 20 utilities by test count
            top_utils = sorted(utils_data.items(), key=lambda x: x[1]['total_tests'], reverse=True)[:20]

            fig, ax = plt.subplots(figsize=(14, 8))

            utilities = [util for util, _ in top_utils]
            success_rates = [stats['overall_success_rate'] for _, stats in top_utils]

            bars = ax.barh(utilities, success_rates)

            # Color bars based on success rate
            for bar, rate in zip(bars, success_rates):
                if rate >= 95:
                    bar.set_color('green')
                elif rate >= 80:
                    bar.set_color('orange')
                else:
                    bar.set_color('red')

            ax.set_xlabel('Success Rate (%)')
            ax.set_title('Success Rates by Utility (Top 20 by Test Count)')
            ax.grid(True, alpha=0.3, axis='x')

            plt.tight_layout()
            plt.savefig(self.output_dir / 'utility_success_rates.png', dpi=150, bbox_inches='tight')
            plt.close()

        # 3. Test Results Pie Chart
        overall = self.stats['overall_statistics']
        fig, ax = plt.subplots(figsize=(8, 8))

        labels = ['Pass', 'Fail', 'Skip', 'Error']
        sizes = [overall['pass'], overall['fail'], overall['skip'], overall['error']]
        colors = ['#2ecc71', '#e74c3c', '#f39c12', '#9b59b6']

        # Only include non-zero categories
        filtered_data = [(label, size, color) for label, size, color in zip(labels, sizes, colors) if size > 0]
        if filtered_data:
            labels, sizes, colors = zip(*filtered_data)

            wedges, texts, autotexts = ax.pie(sizes, labels=labels, colors=colors, autopct='%1.1f%%', startangle=90)
            ax.set_title('Test Results Distribution')

            plt.tight_layout()
            plt.savefig(self.output_dir / 'test_results_pie.png', dpi=150, bbox_inches='tight')
            plt.close()

    def _generate_html_report(self, include_charts=False):
        """Generate an HTML report."""
        # For simplicity, convert markdown to basic HTML
        markdown_content = self._generate_markdown_report(include_charts)

        html = f"""<!DOCTYPE html>
<html>
<head>
    <title>GNU Test Statistics Report</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 40px; }}
        table {{ border-collapse: collapse; width: 100%; }}
        th, td {{ border: 1px solid #ddd; padding: 8px; text-align: left; }}
        th {{ background-color: #f2f2f2; }}
        code {{ background-color: #f4f4f4; padding: 2px 4px; border-radius: 3px; }}
        h1, h2 {{ color: #333; }}
    </style>
</head>
<body>
<pre>{markdown_content}</pre>
</body>
</html>"""
        return html

    def _generate_json_report(self):
        """Generate a JSON report with summary statistics."""
        return json.dumps(self.stats, indent=2)


def main():
    parser = argparse.ArgumentParser(
        description='Visualize GNU test statistics',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__
    )

    parser.add_argument('stats_file', help='Statistics JSON file')
    parser.add_argument('--output-dir', type=Path, default='./reports', help='Output directory')
    parser.add_argument('--format', choices=['markdown', 'html', 'json'], default='markdown', help='Output format')
    parser.add_argument('--charts', action='store_true', help='Generate charts (requires matplotlib)')
    parser.add_argument('--verbose', action='store_true', help='Enable verbose output')

    args = parser.parse_args()

    # Check if charts are requested but matplotlib is not available
    if args.charts and not MATPLOTLIB_AVAILABLE:
        print("Warning: Charts requested but matplotlib not available. Install with: pip install matplotlib seaborn")
        args.charts = False

    try:
        # Load statistics
        with open(args.stats_file, 'r') as f:
            stats_data = json.load(f)

        if args.verbose:
            print(f"Loaded statistics from {args.stats_file}")
            print(f"Runs analyzed: {stats_data['metadata']['runs_analyzed']}")

        # Generate report
        visualizer = GnuTestStatsVisualizer(stats_data, args.output_dir, args.format)
        report = visualizer.generate_report(include_charts=args.charts)

        # Save report
        if args.format == 'markdown':
            output_file = args.output_dir / 'gnu-test-report.md'
        elif args.format == 'html':
            output_file = args.output_dir / 'gnu-test-report.html'
        else:  # json
            output_file = args.output_dir / 'gnu-test-report.json'

        with open(output_file, 'w') as f:
            f.write(report)

        print(f"Report generated: {output_file}")

        if args.charts and MATPLOTLIB_AVAILABLE:
            print(f"Charts generated in: {args.output_dir}")

    except FileNotFoundError:
        print(f"Error: Statistics file '{args.stats_file}' not found.")
        sys.exit(1)
    except json.JSONDecodeError:
        print(f"Error: '{args.stats_file}' is not a valid JSON file.")
        sys.exit(1)
    except Exception as e:
        print(f"Error: {e}")
        if args.verbose:
            import traceback
            traceback.print_exc()
        sys.exit(1)


if __name__ == '__main__':
    main()
